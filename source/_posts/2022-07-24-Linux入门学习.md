---
title: Linux入门学习
date: 2022-07-24 17:56:47
categories:
  - computer
tags:
  - linux
---

#  Linux 入门学习

## 系统文件目录

root：root用户目录

home：普通用户目录，每个用户都有一个目录

etc:  系统管理的一些配置文件和子目录

usr：用户文件目录

boot：Linux启动核心文件

Lib: 系统开机所需要的基本动态链接共享库

bin: 常用命令目录

`sbin`: 系统管理员命令目录

dev: device 设备描述文件目录

mnt: 挂载文件目录

opt: 安装包文件存放目录

Var: 不断变化，扩充的文件目录，日志存放 

/selinux[security-enhanced linux]: 安全子系统，控制程序只能访问特定文件

## vim 快捷键

复制：`yy` 复制当前行 `5yy` 复制当前光标下5行

粘贴：`p`粘贴复制内容至光标处

删除：`dd` 删除当前行 `5dd`删除光标下5行

查找：`/关键字` 回车查找 **输入n**就是查找下一个

跳至尾行：`G`

跳至首行：`gg`

跳至指定行：`20+G` 跳至第20行 无法跳至未存在的行。

撤销：`u`

显示行号：`set nu`

隐藏行号：`set nonu`

**经典键位图**

![image-20220721214935405](https://raw.githubusercontent.com/zhenglinsmile/picture/master/img/202207241758134.png)

### 关机&重启

 ```shell
shutdown -h now # 立刻关机
shutdown -h 1   # 一分钟后关机
shutdown -r now # 立刻重启
reboot 					# 立刻重启
halt						# 立刻关机
sync						# 把内存的数据同步到磁盘
 ```

**用户登录注销**

```shell
# 登录
# 切换为其它用户
su -root 

# 注销root账号
logout # 这个命令执行之后用户为原来的登录用户
# 再次注销
logout # 退出登录 
```

## 用户管理

```shell
# 添加用户
useradd username

# 设置用户密码
passwd username

# delete user
userdel usernmae
# delete user and user home
userdel username -r
```

### **查看用户信息**

```shell
# 查看指定用户的信息
id username

# 查看当前用户信息
whoami
```

### **用户组**

创建用户不指定用户组，会默认创建一个与用户名一样的用户组。

| 命令                       | 说明             |
| -------------------------- | ---------------- |
| `groupadd 组名`            | 添加用户组       |
| `useradd -g 用户组 用户名` | 添加用户到用户组 |
| `usermod -g 用户组 用户名` | 修改用户用户组   |

### 用户和组相关文件

-   **/etc/passwd 文件**
    -   用户的配置文件，记录用户的各种信息
    -   **格式：用户名：口令：用户标识号：组标识号：注释性描述：主目录：登录shell**

-   **/etc/shadow 文件**
    -   口令的配置文件
    -   **每行格式：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标识**
-   **/etc/group 文件**
    -   组配置文件
    -   **格式： 组名：口令：组标识号：组内用户列表**

### 文件/目录所在组

| 命令                                        | 说明                                              |
| ------------------------------------------- | ------------------------------------------------- |
| `chargp 组名 文件名`                        | 修改文件所属用户组                                |
| `chown 账号名称 文件或目录`                 | 修改文件/文件夹所属用户                           |
| `chown [-R] 账号名称:用户组名称 文件或目录` | **-R：递归更改**  修改文件/文件夹所属用户：用户组 |
| `chargp [-R] 组名 文件名`                   | **-R：递归更改**  修改文件/文件夹所属用户组       |

## 文件权限

在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。

-   当为 **d** 则是目录
-   当为 **-** 则是文件；
-   若是 **l** 则表示为链接文档(link file)；
-   若是 **b** 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；
-   若是 **c** 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。

**r** 代表可读(read)、 **w** 代表可写(write)、 **x** 代表可执行(execute)，这三个权限的位置不会改变，如果没有权限，就会出现减号 **-** 而已。

**文件权限示意图**

![img](https://raw.githubusercontent.com/zhenglinsmile/picture/master/img/202207222209757.jpg)

**权限说明**

![image-20220722221137653](https://raw.githubusercontent.com/zhenglinsmile/picture/master/img/202207222211725.png)

### 文件｜目录 权限修改

-   `+ - = 变更权限`

    **`u` 所有者**

    **`g` 所有组**

    **`o` 其它**

    **`a` 所有人**

    -   `chmod u=rwx,g=rx,o=x 文件/目录名` 文件所有者拥有全部权限｜ 文件所有组拥有读、执行权限｜其它用户执行权限
    -   `chmod o+w 文件/目录名` 文件其它用户增加写权限
    -   `chmod a-x 文件/目录名` 文件所有用户全部去掉执行权限

-   `通过数字变更权限`

    -   `chmod 741 文件/目录名 `

    `r = 4 | w = 2 | x = 1`

### **root密码忘记处理**

1.  启动Linux时，在启动界面按`e` 进入下图，在图示位置输入`init=/bin/sh`

![image-20220721230038110](https://raw.githubusercontent.com/zhenglinsmile/picture/master/img/202207212300175.png)

**重置密码**

1.  输入 `Ctrl + x` 进入未知模式
2.  输入 `mount -o remount,rw /`
3.  输入 `passwd`
4.  输入新密码
5.  再次输入新密码
6.  输入 `touch /.autorelabel`
7.  输入 `exec /sbin/init`

![image-20220721230153503](https://raw.githubusercontent.com/zhenglinsmile/picture/master/img/202207241758108.png)

### 帮助指令

```shell
# 通用
man 命令名
man ls
# 查看内置命令
help cd
```

### 文件目录指令

```shell
# 创建单级目录
mkdir 文件夹名称

# 创建多级目录
mkdir -p 文件夹名称

# 删除空目录
rmdir 文件夹名称

# 删除多级空目录
rmdir 文件夹名称/子文件夹名称

# 删除多级目录（非空/空）
rm -rf 文件夹名称
```

### **查看命令**

```shell
# 带行号查看文件内容
cat -n 文件名

# 分页查看文件
cat 文件名 | more
```

### **more指令**

`more 文件名` 分页查看文件内容

| 操作          | 功能                     |
| ------------- | ------------------------ |
| 空白键(space) | 代表向下翻一页           |
| Enter         | 代表向下翻一行           |
| q             | 退出                     |
| Crtl + F      | 向下滚动一屏             |
| Crtl + B      | 返回上一屏               |
| =             | 输出当前行的行号         |
| :f            | 输出文件名和当前行的行号 |

### **less指令**

`less 文件名` 分页查看文件内容 对大文件效率较高

| 操作          | 功能                                  |
| ------------- | ------------------------------------- |
| 空白键(space) | 代表向下翻一页                        |
| Pagedown      | 代表向下翻一行                        |
| Pageup        | 代表向上翻一行                        |
| / 字串        | 向下搜索[字串],n:向下查找；N 向上查找 |
| ？字串        | 向上搜索[字串],n:向上查找；N 向下查找 |
| q             | 退出                                  |

## **常用命令**

| 指令                                | 说明                     |
| ----------------------------------- | ------------------------ |
| `echo`                              | 输出内容                 |
| `head 文件名`                       | 查看文件前10行内容       |
| `head -n 5 文件名`                  | 查看文件前5行内容        |
| `tail 文件名`                       | 查看文件后10行内容       |
| `tail -n 5 文件名`                  | 查看文件后5行内容        |
| `tail -f 文件`                      | **实时追踪文件更新内容** |
| `echo "conent" > 文件名`            | 覆盖文件内容             |
| `echo "conent" >> 文件名`           | 向文件中追加内容         |
| `ln -s 原始目录（文件） 软连接文件` | **创建软链接**           |
| `hisoty`                            | 查看所有历史指令         |
| `history 10`                        | 查看最近使用的10条指令   |
| `!5`                                | 执行历时编号为5的指令    |

**示例**

```shell
# 将指定目录下的文件列表写入到指定文件中 
ls -l /home > /home/info.txt # 文件不存在在会自动创建

# 将当前日历信息追加到指定文件中
cal >> /home/mycal
```

## 时间日期命令

### 日期

| 指令                            | 说明                         |
| ------------------------------- | ---------------------------- |
| `date`                          | Fri Jul 22 13:41:30 CST 2022 |
| `date +%Y`                      | 2022 年                      |
| `date +%m`                      | 07 月份                      |
| `date +%d`                      | 22 天                        |
| `date "+%Y-%m-%d %H:%M:%S"`     | 2022-07-22 13:44:42          |
| `date -s "2022-07-22 13:00:00"` | 设置时间                     |
| `cal`                           | 查看当月日历                 |
| `cal 2022`                      | 查看2022整年日历             |

### **服务器系统时间重置**

```shell
# 安装服务
yum install ntp
# 更新时间
ntpdate -u ntp.api.bz

# 常用时间服务器地址
# 中国国家授时中心：210.72.145.44

# NTP服务器(上海) ：ntp.api.bz
```

## 查找命令

`find [搜索范围][选项] `

| 命令                            | 说明                                         |
| ------------------------------- | -------------------------------------------- |
| `find / -name 文件名`           | 按文件名查找                                 |
| `find /root -user [用户名]`     | 按用户名查找                                 |
| `find /root -size [文件大小]`   | 按文件大小查找                               |
| `updatedb`                      | **更新locate记录**                           |
| `locate 文件名`                 | 查找指定文件路径（**需要先使用`updatedb`**） |
| `which 指令`                    | 查找对应的指令在哪个目录下：which ls         |
| `cat hello.txt | grep -n "yes"` | 查看hello.txt文件中yes所在行                 |
| `grep -n -i "yes" hello.txt`    | 查看hello.txt文件中yes(忽略大小写)所在行     |

**`+n`表示大于n**

**`-n`表示小于n**

**常用的单位有`k、M、G`**

**示例**

```shell
# +n 
# 查找服务器上size > 200M的全部文件
find / -size +200M 

# -n 显示行好 -i 忽略大小写
grep -n -i "yes" hello.txt
```

##  压缩和解压

### **gzip**

`gzip 文件名`文件压缩

`gunzip 文件名` 文件解压缩

### zip

`zip [选项] xxx.zip 将要压缩的内容`

选项 -r :递归压缩，即压缩目录

`unzip [选项] xxx.zio` 将xxx.zip 解压缩

**选项 -d** : 指定解压文件存放目录

### tar

| 命令 | 说明               |
| ---- | ------------------ |
| -c   | 产生.tar打包文件   |
| -v   | 显示详情信息       |
| -f   | 指定压缩后的文件名 |
| -z   | 打包同事压缩       |
| -x   | 解包.tar文件       |

**示例**

```shell
# 将多个文件打包压缩
tar -zcvf file.tar.gz ok.txt text.txt
```

## cornd任务调度

```shell
crontab [-u username]　　　　//省略用户表表示操作当前用户的crontab
    -e      (编辑工作表)
    -l      (列出工作表里的命令)
    -r      (删除工作作)

# 重启任务调度
service crond restart     
```

**crontab -e**进入当前用户的工作表编辑，是常见的vim界面。每行是一条命令。

crontab的命令构成为 时间+动作，其时间有**分、时、日、月、周**五种，操作符有

-   ***** 取值范围内的所有数字
-   **/** 每过多少个数字
-   **-** 从X到Z
-   **，**散列数字

**实例**

```shell
# 建立一个定时任务
crontab -u root -e
# 在打开文件中写入 写入后保存即启动了任务
# 每分钟执行一次 将文件下的所有内容写入/home/to.txt
*/1 * * * * ls -l /etc/ > /home/to.txt

# 查看corn任务
crontab -l

# 移除cron任务
crontab -r

# 每1分钟执行一次myCommand
* * * * * myCommand

# 每小时的第3和第15分钟执行
3,15 * * * * myCommand

# 在上午8点到11点的第3和第15分钟执行
3,15 8-11 * * * myCommand

# 每隔两天的上午8点到11点的第3和第15分钟执行
3,15 8-11 */2  *  * myCommand

# 每周一上午8点到11点的第3和第15分钟执行
3,15 8-11 * * 1 myCommand

# 每晚的21:30重启smb
30 21 * * * /etc/init.d/smb restart

# 每月1、10、22日的4 : 45重启smb
45 4 1,10,22 * * /etc/init.d/smb restart
```

## atd定时任务

**`atd`属于一次性定时任务，每个任务只会执行一次**

需要注意先检查`atd`进程是否在执行中`ps -ef|grep atd`

 **at [选项] [时间]**

`arem 任务编号` 删除指定编号的任务

**at 命令选项及含义**

| 选项          | 含义                                                         |
| ------------- | ------------------------------------------------------------ |
| -m            | 当 at 工作完成后，无论命令是否输出，都用 E-mail 通知执行 at 命令的用户。 |
| -c 工作标识号 | 显示该 at 工作的实际内容。                                   |
| -t 时间       | 在指定时间提交工作并执行，时间格式为 [[CC]YY]MMDDhhmm。      |
| -d            | 删除某个工作，需要提供相应的工作标识号（ID），同 atrm 命令的作用相同。 |
| -l            | 列出当前所有等待运行的工作，和 atq 命令具有相同的额作用。    |
| -f 脚本文件   | 指定所要提交的脚本文件。                                     |

**at 命令时间参数可用格式**

| 格式                       | 用法                                                         |
| -------------------------- | ------------------------------------------------------------ |
| HH:MM                      | 比如 04:00 AM。如果时间已过，则它会在第二天的同一时间执行。  |
| Midnight（midnight）       | 代表 12:00 AM（也就是 00:00）。                              |
| Noon（noon）               | 代表 12:00 PM（相当于 12:00）。                              |
| Teatime（teatime）         | 代表 4:00 PM（相当于 16:00）。                               |
| 英文月名 日期 年份         | 比如 January 15 2018 表示 2018 年 1 月 15 号，年份可有可无。 |
| MMDDYY、MM/DD/YY、MM.DD.YY | 比如 011518 表示 2018 年 1 月 15 号。                        |
| now+时间                   | 以 minutes、hours、days 或 weeks 为单位，例如 now+5 days 表示命令在 5 天之后的此时此刻执行。 |

**示列**

```shell
[coot@localhost ~]# cat /root/hello.sh
#!/bin/bash
echo "hello world!!"
#该脚本会打印"hello world!!"
[root@localhost ~]# at now +2 minutes
at> /root/hello.sh >> /root/hello.log
#执行hello.sh脚本，并把输出写入/root/hello.log文件
at> <EOT>
#使用Ctrl+D快捷键保存at任务
job 8 at 2013-07-25 20:54 #这是第8个at任务,会在2013年7月25日20:54执行
[root@localhost ~]# at -c 8
#查询第8个at任务的内容
...省略部分内容...
#主要定义系统的环境变量
/root/hello.sh >> /root/hello.log
#可以看到at执行的任务
```

## 磁盘相关

### 磁盘挂载

**步骤如下**

1.  添加硬盘
2.  硬盘分区
3.  分区格式化
4.  创建目录
5.  分区挂载

```shell
# 添加硬盘 注意 添加硬盘后需要重启才能识别设备
# 查看硬盘名称
[root@localhost ~]# lsblk 
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0   20G  0 disk # 原硬盘
├─sda1            8:1    0  200M  0 part /boot/efi
├─sda2            8:2    0    1G  0 part /boot
└─sda3            8:3    0 18.8G  0 part 
  ├─centos-root 253:0    0 16.8G  0 lvm  /
  └─centos-swap 253:1    0    2G  0 lvm  [SWAP]
sdb               8:16   0    1G  0 disk # 新加的硬盘
sr0              11:0    1  973M  0 rom

# 硬盘分区
[root@localhost ~]# fdisk /dev/sdb 
Welcome to fdisk (util-linux 2.23.2).

Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table
Building a new DOS disklabel with disk identifier 0x5ec44374.

Command (m for help): m # 帮助
Command action
   a   toggle a bootable flag
   b   edit bsd disklabel
   c   toggle the dos compatibility flag
   d   delete a partition
   g   create a new empty GPT partition table
   G   create an IRIX (SGI) partition table
   l   list known partition types
   m   print this menu
   n   add a new partition # 分区数量
   o   create a new empty DOS partition table
   p   print the partition table
   q   quit without saving changes
   s   create a new empty Sun disklabel
   t   change a partition's system id
   u   change display/entry units
   v   verify the partition table
   w   write table to disk and exit # 写入操作并退出
   x   extra functionality (experts only)

Command (m for help): n # 分区数量
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): p # 分区数量
# 省略 ...... 

Command (m for help): w # 写入操作并退出
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.
[root@localhost ~]# lsblk 
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0   20G  0 disk 
├─sda1            8:1    0  200M  0 part /boot/efi
├─sda2            8:2    0    1G  0 part /boot
└─sda3            8:3    0 18.8G  0 part 
  ├─centos-root 253:0    0 16.8G  0 lvm  /
  └─centos-swap 253:1    0    2G  0 lvm  [SWAP]
sdb               8:16   0    1G  0 disk 
└─sdb1            8:17   0 1023M  0 part 
sr0              11:0    1  973M  0 rom

## 分区格式化 注意地址是/dev/sdb1
[root@localhost ~]# mkfs -t ext4 /dev/sdb1
mke2fs 1.42.9 (28-Dec-2013)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
65536 inodes, 261888 blocks
13094 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=268435456
8 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks: 
        32768, 98304, 163840, 229376

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (4096 blocks): done
Writing superblocks and filesystem accounting information: done

[root@localhost ~]# lsblk -f
NAME   FSTYPE  LABEL   UUID                                   MOUNTPOINT
sda                                                           
├─sda1 vfat            BAA0-0888                              /boot/efi
├─sda2 xfs             90310ed0-d336-4f5e-9341-33c06c13c23b   /boot
└─sda3 LVM2_me         Px4QV7-dZba-mIm7-fcam-jtdq-jZtK-qxHLyC 
  ├─centos-root
       xfs             38446ac0-2dad-4f72-bffd-a1db0a419482   /
  └─centos-swap
       swap            2853a0af-5e55-497c-ad18-39354cfab4e5   [SWAP]
sdb    ext4            cf92cda9-9d49-4434-8494-c698876037b0   
└─sdb1 ext4            0a1596cd-a209-41c8-bb73-26e9c0636fec   
sr0    iso9660 CentOS 7 x86_64
                       2020-11-03-14-55-29-00
# 查看分区情况                       
[root@localhost ~]# lsblk
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0   20G  0 disk 
├─sda1            8:1    0  200M  0 part /boot/efi
├─sda2            8:2    0    1G  0 part /boot
└─sda3            8:3    0 18.8G  0 part 
  ├─centos-root 253:0    0 16.8G  0 lvm  /
  └─centos-swap 253:1    0    2G  0 lvm  [SWAP]
sdb               8:16   0    1G  0 disk 
└─sdb1            8:17   0 1023M  0 part 
sr0              11:0    1  973M  0 rom 
## 创建新文件夹
[root@localhost ~]# cd /
[root@localhost /]# mkdir newdisk
## 挂载分区
[root@localhost /]# mount /dev/sdb1 /newdisk/
## 查看挂载结果
[root@localhost /]# lsblk
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0   20G  0 disk 
├─sda1            8:1    0  200M  0 part /boot/efi
├─sda2            8:2    0    1G  0 part /boot
└─sda3            8:3    0 18.8G  0 part 
  ├─centos-root 253:0    0 16.8G  0 lvm  /
  └─centos-swap 253:1    0    2G  0 lvm  [SWAP]
sdb               8:16   0    1G  0 disk 
└─sdb1            8:17   0 1023M  0 part /newdisk
sr0              11:0    1  973M  0 rom
```

### 永久挂载

1.  修改`/etc/fstan`文件

2.  执行mount -a`生效

 ```shell
[root@localhost ~]# cat /etc/fstab 

#
# /etc/fstab
# Created by anaconda on Thu Jul 21 06:03:22 2022
#
# Accessible filesystems, by reference, are maintained under '/dev/disk'
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
# 增加挂载信息
# UUID 即为lsblk -f 下对应的uuid 也可以直接使用磁盘名（lsblk 结果中的Name）代替
/dev/sdb1               /newdisk                ext4     defaults        0 0
/dev/mapper/centos-root /                       xfs     defaults        0 0
UUID=90310ed0-d336-4f5e-9341-33c06c13c23b /boot                   xfs     defaults        0 0
UUID=BAA0-0888          /boot/efi               vfat    umask=0077,shortname=winnt 0 0
/dev/mapper/centos-swap swap                    swap    defaults        0 0
 ```

### 硬盘空间

`df -h` 查看磁盘查询空间大小

```shell
# 结果如下
Filesystem               Size  Used Avail Use% Mounted on
devtmpfs                 898M     0  898M   0% /dev
tmpfs                    910M     0  910M   0% /dev/shm
tmpfs                    910M   13M  897M   2% /run
tmpfs                    910M     0  910M   0% /sys/fs/cgroup
/dev/mapper/centos-root   17G  2.5G   15G  15% /
/dev/sdb1                991M  2.6M  922M   1% /newdisk
/dev/sda2               1014M  143M  872M  15% /boot
/dev/sda1                200M   12M  189M   6% /boot/efi
tmpfs                    182M     0  182M   0% /run/user/0
```

`du [选项] -h 磁盘名` 查看指定磁盘空间大小

**-s 指定目录占用大小汇总**

**-h 带计量单位**

**-a 带文件**

**--max-depth=1 指定子目录深度的**

**-c 列出明细的同时，增加汇总值**

```shell
# 查看/目录下一级目录大小
# du -h --max-depth=1 -c /
122M    /boot
0       /dev
du: cannot access ‘/proc/9713/task/9713/fd/4’: No such file or directory
du: cannot access ‘/proc/9713/task/9713/fdinfo/4’: No such file or directory
du: cannot access ‘/proc/9713/fd/3’: No such file or directory
du: cannot access ‘/proc/9713/fdinfo/3’: No such file or directory
0       /proc
21M     /run
0       /sys
36M     /etc
28K     /root
644M    /var
8.0K    /tmp
1.8G    /usr
0       /home
0       /media
0       /mnt
56M     /opt
0       /srv
20K     /newdisk
2.6G    /
2.6G    total # 汇总
```

### 相关示例

```shell
# 统计/opt目录下文件数量
ls -al /opt |grep "^-"|wc -l

# 统计/opt目录下目录数量
ls -al /opt |grep "^d"|wc -l

# 统计/opt目录下全部文件数量 包含子文件夹 -R 递归获取
ls -alR /opt |grep "^-"|wc -l

# 以树状结构展示/opt目录
tree /opt 
```

## **虚拟机Centos 环境网络配置**

`/etc/hosts` host映射文件路径

### **网络配置**

```shell
# 禁用selinux
# 将SELINUX的值设置为disabled：
vi/etc/selinux/config
# 查看是否设置完成：
cat /etc/selinux/config

# 重启vmware network服务解决问题
sudo /Applications/VMware\ Fusion.app/Contents/Library/vmnet-cli --stop
sudo /Applications/VMware\ Fusion.app/Contents/Library/vmnet-cli --start
```

#### **桥接模式配置**

```shell
# 修改网络配置文件
# vi /etc/sysconfig/network-scripts/ifcfg-ens33
TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
# BOOTPROTO=dhcp
# 修改为static
BOOTPROTO=static
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens33
UUID=cc974683-bbfc-436a-82ee-ec7bae3a1f9a
DEVICE=ens33
# 需改为yes
ONBOOT=yes
# 修改为想要指定的IP 必须在合适的网段
IPADDR=192.168.1.7
# 修改ni
NETMASK=255.255.255.0
# 网关地址 需要查看本机
GATEWAY=192.168.1.1
# DNS
DNS1=114.114.114.114
```

**网卡重启**

```shell
# 网卡重启
systemctl restart network

# 测试网络
ping baidu.com
```

**通过shell访问很慢处理**

```shell
# vi /etc/ssh/sshd_config 

# 修改DNS这一项
#UseDNS yes
UseDNS no

# 然后重启sshd服务
systemctl restart sshd
```

#### **NAT模式配置**

**1. 设宿主机 - 置虚拟机网段**

```shell
sudo vi /Library/Preferences/VMware\ Fusion/networking

## 文件内容
iVERSION=1,0
answer VNET_1_DHCP yes
answer VNET_1_DHCP_CFG_HASH 7C14F34F7AB4863D57D5F6D2FB60FFAB66E6D30B
answer VNET_1_HOSTONLY_NETMASK 255.255.255.0
answer VNET_1_HOSTONLY_SUBNET 172.16.203.0
answer VNET_1_VIRTUAL_ADAPTER yes
# 这里需要修改为no
answer VNET_8_DHCP no
answer VNET_8_DHCP_CFG_HASH C3F308DBD389D4B9157B541F125D9BEC648CC715
answer VNET_8_HOSTONLY_NETMASK 255.255.255.0
# 这里修改为你想要指定的虚拟机网段
answer VNET_8_HOSTONLY_SUBNET 192.168.111.0
answer VNET_8_NAT yes
answer VNET_8_VIRTUAL_ADAPTER yes
add_bridge_mapping en0 2
```

**2. 宿主机 - 设置虚拟机IP**

```shell
sudo vi /Library/Preferences/VMware\ Fusion/vmnet8/nat.conf

[host]
# Use MacOS network virtualization API
useMacosVmnetVirtApi = 1

# NAT gateway address
# 这里修改为你想要指定的虚拟机网关地址
ip = 192.168.111.1
netmask = 255.255.255.0
```

**3. 虚拟机 - 配置虚拟机网络**

```shell
# 修改虚拟机指定文件
vi /etc/sysconfig/network-scripts/ifcfg-ens33

# 文件内容如下
TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=static
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens33
UUID=53b12ca8-1edf-406b-a51a-e2b32c931506
DEVICE=ens33
ONBOOT=yes
# 修改为想要配置的虚拟机IP
IPADDR=192.168.111.11
# 
NETMASK=255.255.255.0
# 虚拟机网关地址 需
GATEWAY=192.168.111.1
DNS1=114.114.114.114

## 重启虚拟机网络 测试
```

### 虚拟机网络模式

抄袭自：https://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html

-   **桥接模式**

缺点：虚拟机与物理机处于同一网段，一个网段内最大的连接数量是有限的，最大255个（还需要去除.1（网关地址）和.255（广播地址））。

```
桥接网络是指本地物理网卡和虚拟网卡通过VMnet0虚拟交换机进行桥接，物理网卡和虚拟网卡在拓扑图上处于同等地位，那么物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机,所以两个网卡的IP地址也要设置为同一网段。

   所以当我们要在局域网使用虚拟机，对局域网其他pc提供服务时，例如提供ftp，提供ssh，提供http服务，那么就要选择桥接模式。

   例如大学宿舍里有一个路由器，宿舍里四个人连接这个路由器，路由器的wanip就不理会了，这个ip是动态获取的，而lanip默认是192.168.1.1,子网掩码是255.255.255.0。而其他四个人是自动获取ip，假设四个人的ip是:

   A:192.168.1.100/255.255.255.0,  B:192.168.1.101/255.255.255.0,  C:192.168.1.102/255.255.255.0,  D:192.168.1.103/255.255.255.0

   那么虚拟机的ip可以设置的ip地址是192.168.1.2-192.168.1.99,192.168.1.104-192.168.1.254(网络地址全0和全1的除外，再除去ABCD四个人的ip地址)

  那么虚拟机的ip地址可以设置为192.168.1.98/255.255.255.0,设置了这个ip地址，ABCD这四个人就可以通过192.168.1.98访问虚拟机了，如果虚拟机需要上外网，那么还需要配置虚拟机的路由地址，就是192.168.1.1了，这样，虚拟机就可以上外网了，但是，上网我们一般是通过域名去访问外网的，所以我们还需要为虚拟机配置一个dns服务器，我们可以简单点，把dns服务器地址配置为google的dns服务器:8.8.8.8,到此，虚拟机就可以上网了。
```

-   **NAT模式**

```
NAT模式中，就是让虚拟机借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。

   NAT模式中，虚拟机的网卡和物理网卡的网络，不在同一个网络，虚拟机的网卡，是在vmware提供的一个虚拟网络。

   NAT和桥接的比较:

   (1) NAT模式和桥接模式虚拟机都可以上外网。

   (2) 由于NAT的网络在vmware提供的一个虚拟网络里，所以局域网其他主机是无法访问虚拟机的，而宿主机可以访问虚拟机，虚拟机可以访问局域网的所有主机，因为真实的局域网相对于NAT的虚拟网络，就是NAT的虚拟网络的外网，不懂的人可以查查NAT的相关知识。

   (3) 桥接模式下，多个虚拟机之间可以互相访问；NAT模式下，多个虚拟机之间也可以相互访问。

   如果你建一个虚拟机，只是给自己用，不需要给局域网其他人用，那么可以选择NAT，毕竟NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，只要虚拟机的网路配置是DHCP，那么你不需要进行任何其他的配置，只需要宿主机器能访问互联网即可，就可以让虚拟机联网了。

  例如你想建多个虚拟机集群，作为测试使用，而宿主机可能是一个笔记本，ip不固定。这种应用场景，我们需要采用nat模式了，但是我们要考虑一个问题，虚拟机之间是需要互访的，默认采用dhcp，虚拟机的ip每次重启，ip都是不固定的，所以我们需要手工设置虚拟机的ip地址。

  但是我们对虚拟机网卡所在的虚拟网络的信息还一无所知，例如虚拟机网络的路由地址，子网掩码，所以我们需要先查下nat虚拟网络的信息。

  使用vmware,在Edit->Virtual Network Editor中配置好虚拟网络信息后看到下图所示，注意VMnet8，VMnet8相当于是本机的一个路由，虚拟机设置NAT后就通过这个路由进行上网的，可以查看其网络地址，路由地址，子网掩码。

  选择VMnet8->NAT设置,可以看到子网ip显示为192.168.233.0，子网掩码是255.255.255.0，那路由地址呢，其实就是网关IP了，都是同个东西，这里是192.168.233.2。

  接下来就好办了，在对应的虚拟机设置好ip，子网掩码，路由地址就可以上外网了，至于dns可以设置为8.8.8.8.
```

-   **Host-Only**

```
在Host-Only模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实Host-Only网络和NAT网络很相似，不同的地方就是Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。主机和虚拟机之间的通信是通过VMware Network Adepter VMnet1虚拟网卡来实现的。

　　Host-Only的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。如果你想为VMnet1网段提供路由功能，那就需要使用RRAS，而不能使用XP或2000的ICS，因为ICS会把内网的IP地址改为192.168.0.1，但虚拟机是不会给VMnet1虚拟网卡分配这个地址的，那么主机和虚拟机之间就不能通信了。 
```



## 进程管理

### `top`指令

`top ` 动态查看当前运行的进程信息

![image-20220723205756338](https://raw.githubusercontent.com/zhenglinsmile/picture/master/img/202207232057417.png)

再这个界面：**输入P 按照CPU占用大小排序 输入M按照内存占用大小排序**

| 命令            | 说明                                   |
| --------------- | -------------------------------------- |
| `k`             | 输入k，用要求输入pid，然后杀死指定进程 |
| `P`             | 按照CPU占用大小排序                    |
| `M`             | 按照内存占用大小排序                   |
| `N`             | 按照PID大小排序                        |
| `q`             | 退出top                                |
| `top -u 用户名` | 查看指定用户名进程信息                 |

### `ps`指令

`ps -a` 显示当前终端的所有进程信息

`ps -u` 以用户的格式显示进程信息

`pa -x` 显示后台进程运行的参数

`-au` 显示较详细的资讯

`-aux` 显示所有包含其他使用者的行程

### `kill` 指令

| 命令             | 说明                                           |
| ---------------- | ---------------------------------------------- |
| `kill pid`       | kill指定进程                                   |
| `killall 进程名` | 根据进程名，kill指定进程，它的子进程都会被kill |

### 进程树

`pstree` 显示进程树

`-p` 显示进程号

![image-20220723181359696](https://raw.githubusercontent.com/zhenglinsmile/picture/master/img/202207241758334.png)

### 端口状态查询

| 命令          | 选项 | 说明                                     |
| ------------- | ---- | ---------------------------------------- |
| `netstat`     |      | 查看端口信息                             |
| `netstat -an` |      | 以一定的端口信息排列                     |
| `netstat -p`  |      | 查看对应的端口 进程信息                  |
|               | `-a` | 显示所有选项，默认不显示LISTEN相关。     |
|               | `-t` | **(tcp) 仅显示tcp相关选项**              |
|               | `-u` | **(udp) 仅显示udp相关选项**              |
|               | `-n` | 拒绝显示别名，能显示数字的全部转化成数字 |
|               | `-l` | 仅列出有在 Listen (监听) 的服务状态      |
|               | `-p` | **查看对应的端口 进程信息**              |
|               | `-r` | 显示路由信息，路由表                     |
|               | `-e` | 显示扩展信息，例如uid等                  |
|               | `-s` | 按各个协议进行统计                       |
|               | `-c` | 每隔一个固定时间，执行该netstat命令      |

## 服务管理

**`service 服务名 [start | stop | restart | reload | status]`**

**centos7之后，很多服务不再使用service而是使用systemctl**

**查看当前系统支持的service服务 ls -l /etc/init.d**

### 运行级别

Linux中有7种运行级别：

0 关机

1 单用户【找回丢失密码】

2 多用户无网络状态

3 **multi-user.target** 多用户有网络状态

4 系统未使用（保留）

5 **graphical.target** 图形界面

6 系统重启

```shell
# 关机
init 0
# 重启
init 6
```

**相关配置文件 /etc/initab**

```shell
# 查看默认运行级别
systemctl get-default

# 设置默认运行级别
systemctl set-default multi-user.target
```

### `chkconfig`指令

**设置服务在某个运行级别开机自启**

了解即可，感觉已经被淘汰了

1.  可以通过chkconfig指令给服务的各个运行级别设置自启动/关闭
2.  chkconfig指令管理的服务可在/etc/init.d 查看
3.  centos7之后 几乎都使用systemctl

**语法**

1.  查看服务 `chkconfig --list`
2.  `chkconfig 服务名 --list`
3.  `chkconfig --level 5 服务名 on/off `设置在某个运行级别下开关某个服务

### `systemctl`指令

**语法 systemctl [start|stop|restart|status] 服务名**

**支持的服务名：在目录`/usr/lib/systemd/system` 下查看** 

**常用命令**

**注意：默认就代表运行级别为3、5**

| 命令                                         | 说明                       |
| -------------------------------------------- | -------------------------- |
| `systemctl list-unit-files`                  | 查看服务开机启动状态       |
| `systemctl list-unit-files | grep firewalld` | 查看防火墙开机启动状态     |
| `systemctl enable 服务名`                    | **永久设置服务开机自启动** |
| `systemctl disable 服务名`                   | **永久关闭服务开机自启动** |
| `systemctl list-unit-files`                  | 查询开机启动项             |
| `systemctl list-unit-files|grep enable`      |                            |
| `systemctl list-unit-files|grep firewalld`   | 查询某个服务是否开机启动   |

### **防火墙设置**

| 命令                                                  | 说明                   |
| ----------------------------------------------------- | ---------------------- |
| `systemctl stop firewalld`                            | 关闭防火墙             |
| `systemctl disable firewalld`                         | 禁止防火墙随着系统启动 |
| `systemctl status firewalld`                          | 查看防火墙状态         |
| `firewall-cmd --permanent --add-port=3306/tcp`        | 打开3306端口/tcp       |
| `firewall -cmd --permanent --add-port=端口号/协议`    | 打开端口               |
| `firewall -cmd --permanent --remove-port=端口号/协议` | 关闭端口               |
| `firewall -cmd --reload`                              | 重新载入 使修改生效    |
| `firewall -cmd --query-port=端口号/协议`              | 查看端口是否开放       |

## `rpm`包管理

### `rpm`包查询

| 命令                     | 说明                     |
| ------------------------ | ------------------------ |
| `rpm -qa`                | 查询所有安装的软件包     |
| `rpm -qa |grep 软件包名` | 查询并过滤               |
| `rpm -q 软件包`          | 查询软件包是否被安装     |
| `rpm -qi 软件包`         | 查询软件包相关信息       |
| `rpm -ql 软件包`         | 查询软件包中的文件       |
| `rpm -qf 文件名`         | 查询指定文件所属的软件包 |

### `rpm`安装卸载

| 命令                  | 选项说明                         | 说明         |
| --------------------- | -------------------------------- | ------------ |
| `rpm -ivh 指定软件包` | `-i: 安装`                       | 安装软件包   |
|                       | `-v:查看安装过程`                |              |
|                       | `-h`:进度条                      |              |
| `rpm -e 指定软件包`   | `--nodeps:强制卸载 忽略依赖关系` | 卸载指定软件 |

###  `yum使用`

| 命令                    | 选项                           | 说明                     |
| ----------------------- | ------------------------------ | ------------------------ |
| `yum list |grep 软件包` |                                | 查询可用的软件列表       |
| `yum list tomcat`       |                                | 查看可用的tomcat安装信息 |
| `yum install xxx`       | `-y：对于需要确认的项自动确认` | 下载安装指定软件         |
| `yum remove xxx`        |                                | 卸载指定软件             |
| `yum list installed`    |                                | 查询使用yum以安装的软件  |
| `yum deplist tomcat`    |                                | 查看软件包相关依赖       |
| `yum info tomcat`       |                                | 查看软件包的描述信息     |
| `yum update`            |                                | 升级所有软件包           |
| `yum update tomcat`     |                                | 升级tocat                |

## 常用环境安装

### `jdk`安装

```shell
# 下载jdk8
# https://www.oracle.com/java/technologies/downloads/#java8
# ftp上传jdk-8u341-linux-x64.tar.gz 到/opt/jdk
# 解压
tar -zxvf /opt/jdk/jdk-8u341-linux-x64.tar.gz
# 移动至安装目录
mv /opt/jdk/jdk1.8.0_341 /usr/local/java/
# 配置环境变量
vim /etc/profile
# 添加如下内容
export JAVA_HOME=/usr/local/java/jdk1.8.0_341
export PATH=$JAVA_HOME/bin:$PATH

# 环境变量生效
source /etc/profile
# 验证
javac 
java -version
```

## `shell`学习

### 变量

-   系统变量

    **可以通过命令 `set` 查看系统已经定义变量**

    `$PATH ` 

    `$PWD`

-   用户自定义变量

    -   定义变量： 变量名=值
    -   撤销变量：unset 变量名
    -   **声明静态变量**：readonly 变量名=值，**注意：不能unset**

#### 语法

-   变量等号两侧**不能有空格**
-   将命令的返回值符给变量
    -   C=\`date\`
    -   C=$(date)

-   `export 变量名=变量` 将变量输出为全局变量
-   `source 配置文件` 刷新配置信息
-   `echo $变量名` 输出环境变量值

**示例**

```shell
#!/bin/bash
echo $PATH

# 申明变量
A=100
echo A=$A

# 撤销变量
unset A
echo A=$A

# 申明静态变量
readonly B=20
echo B=$B

# 错误实例
C=date
echo C=$C

# 赋值
D=`date`
echo D=$D

# 赋值
E=$(date)
echo E=$E

# 撤销静态变量 这里会报错
unset B
```

### 位置参数

| 命令 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| `$n` | `n` 为数字，`$0`代表命令本身 `$1-$9`代表第1到第9个参数 10以上的参数需要使用`${10}、${11}` |
| `$*` | 命令行中的全部参数 把所有参数当作一个整体                    |
| `$@` | 命令行中的全部参数 把每个参数区别对待                        |
| `$#` | 命令行中全部参数个数                                         |

**示例**

```shell
#!/bin/bash
echo 输出第一个参数（即shell脚本名）：$0
echo 输出第二个参数：$1
echo 输出第三个参数：$2
echo 输出第四个参数：$3
echo 输出全部参数：$*
echo 输出全部参数：$@
echo 输出全部参数个数（不包含shell脚本名）：$#
```

### 预定义变量

**后台执行一个sh脚本：`sh /xxx.sh $`**

| 命令 | 说明                                             |
| ---- | ------------------------------------------------ |
| `$$` | **获取当前的进程号**                             |
| `$!` | 获取上一次执行的进程的进程编号                   |
| `$?` | 获取上一次执行的命令的返回状态 **0表示正确执行** |

**示例**

```shell
#!/bin/bash
# 获取当前shell的进程ID
echo 当前shell的进程ID=$$

# 后台运行一个进程
sh /home/shcode/var.sh &

# 获取后台运行的最后一个进程的进程号
echo 获取后台运行的最后一个进程号:$!

# 获取最后一次执行命令的返回状态
echo 最后一次指定的返回状态：$?
```

### 运算表达式

| 命令          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| `$((运算式))` |                                                              |
| `$[运算式]`   | **推荐使用**                                                 |
| `expr m + n`  | `expr`运算符之间需要有空格，如果需要将其结果赋给某个变量，需要使用\`\`。对于`*`需要使用`\*` |

**示例**

```shell
#!/bin/bash

# 计算（2+3）* 4 的值
echo "第一种写法：(2+3)*4="$(((2+3)*4))

echo "第二种写法：(2+3)*4=$[(2+3)*4]"

# 第三种写法 需要将表达式拆分
TEMP=`expr 2 + 3`
RES=`expr $TEMP \* 4`
echo "第三种写法：(2+3)*4=$RES"
```

### 条件语句

#### **`if`语句**

**注意：括号中的表达式前后都有空格，否则会报错！**

**示例**

```shell
#!/bin/bash

if [ "ok" = "ok" ]
then 
        echo "equal"
fi

# 大于判断

if [ 3 -le 5 ]
then
        echo "3 < 5"
fi

# 
if [ -f /home/out.txt ]
then 
        echo "/home/out.txt exist"
fi

score=90
if [ $score -ge 90 ]
then 
        echo "优秀"
elif [ $score -ge 80 ]
        then 
        echo "良好"
elif [$score -ge 70 ]
then 
        echo "中等"
elif [ $score -ge 60 ]
then
        echo "及格"
else
       echo "差"
fi
```

#### `case`语句

```shell
#!/bin/bash

case $1 in
"6")
        echo "周六"
;; 
"7")
        echo "周天"
;;
*)
        echo "工作日"
;;
esac # 这个语法很奇怪了
```

#### **整数比较符**

|        比较符        |     描述     |        实例         |
| :------------------: | :----------: | :-----------------: |
|      -eq, equal      |     等于     | [ 1 -eq 1 ] 为true  |
|    -ne, not equal    |    不等于    | [ 1 -ne 1 ] 为false |
|   -gt, greate than   |     大于     | [ 1 -gt 1 ] 为false |
|   -lt, lesser than   |     小于     | [ 1 -lt 1 ] 为false |
| -ge, greate or equal | 大于或者等于 | [ 1 -ge 1 ] 为true  |
| -le, lesser or equal | 小于或者等于 | [ 1 -le 1 ] 为true  |

**字符串比较符**

| 运算符 |          描述           |                            实例                             |
| :----: | :---------------------: | :---------------------------------------------------------: |
|   ==   |          等于           |                    [ “a” == “a” ] 为true                    |
|   !=   |         不等于          |                   [ “a” != “a” ] 为false                    |
|   -n   | 字符串长度不等于 0 为真 | VAR1=1;VAR2=”” [ -n “$VAR1” ]为 true [ -n “$VAR2” ]为 false |
|   -z   |  字符串长度等于 0 为真  | VAR1=1;VAR2=”” [ -z “$VAR1” ]为false [ -z “$VAR2” ]为 true  |

**注意：使用-n 判断字符串长度时，变量要加双引号，养成好习惯，字符串比较时都加上双引号**

#### **文件测试**

| 测试符 |         描述         |                  实例                   |
| :----: | :------------------: | :-------------------------------------: |
|   -e   | 文件或者目录存在为真 |      [ -e path ] path 存在为 true       |
|   -f   |     文件存在为真     |    [ -f file_path ] 文件存在为 true     |
|   -d   |     目录存在为真     |     [ -d dir_path ] 目录存在为 true     |
|   -r   |     有读权限为真     |  [ -r file_path ]file_path有读权限为真  |
|   -w   |     有写权限为真     |  [ -w file_path ]file_path有写权限为真  |
|   -x   |    有执行权限为真    | [ -x file_path ]file_path有执行权限为真 |
|   -s   | 文件存在且不为空为真 | [-s file_path]file_path存在且不为空为真 |

#### **布尔运算符**

| 运算符 |           描述           |                     实例                      |
| :----: | :----------------------: | :-------------------------------------------: |
|   ！   |   非关系，条件结果取反   |              [ ! 1 -eq 2 ]为true              |
|   -a   | 和关系，在[]表达式中使用 | [ 1 -eq 1 -a 2 -eq 2 ]为true 两者都为真才为真 |
|   -o   | 或关系，在[]表达式中使用 | [ 1 -eq 1 -o 2 -eq 1 ]为true 两者有一真则为真 |

#### **逻辑判断符**

| 判断符 |                       描述                       |                             实例                             |
| :----: | :----------------------------------------------: | :----------------------------------------------------------: |
|   &&   | 逻辑和，在[[]]表达式中或判断表达式是否为真时使用 | [[ 1 -eq 1 && 2 -eq 2 ]]为 true [ 1 -eq 1 ] && echo ‘true’ 如果&&前面的表达式为true则执行后面的 |
|  \|\|  | 逻辑或，在[[]]表达式中或判断表达式是否为真时使用 | [[ 1 -eq 1 \|\| 2 -eq 1 ]]为 true [ 1 -eq 2 ] \|\| echo ‘true’ 如果\|\|前面的表达式为false则执行后面的 |

### `for`循环

```shell
#!/bin/bash

# 顺便测试$* 和 $@ 的区别
# 这里很奇怪 如果我直接用 for i in $* 此时也是独立输出的和$@没有区别
for i in "$*"
do
        echo "num is $i"
done
echo "============b  =============="
for i in "$@"
do
        echo "num is $i"
done

# 计算1-100的和
SUM=0
for (( i=0; i<=100; i++ ))
do
        SUM=$[$SUM+$i]
done
echo "sum=$SUM"
```

### `while`循环

```shell
#!/bin/bash
# 从命令行输入一个数n，统计从1+2+..+n的值是多少？
i=0
SUM=0
while [ $i -lt $1 ]
do
        SUM=$[$SUM+$i]
        i=$[$i+1]
done
echo "结果为：$SUM"
```

### 获取输入

| 命令   | 选项            | 说明                       |
| ------ | --------------- | -------------------------- |
| `read` | `-t 10`         | 设置最大等待时间为10s      |
|        | `-p "请输入～"` | 设置输入提示语为：请输入～ |

**示例**

```shell
#!/bin/bash

# 从控制台输入一个NUM1
read -p "请输入一个数NUM1=" NUM1
echo "你的输入是$NUM1"

# 从控制台输入一个NUM2 最大等待时间设置为10s
read -t 10 -p "请输入一个数NUM2=" NUM2
echo "你的输入是$NUM2"
```

### 标准输入｜输出｜错误输出

`sh shellScript $` 后台执行指定脚本 这样做

| 命令                             |                                                            |      |
| -------------------------------- | ---------------------------------------------------------- | ---- |
| `sh shellScript $`               | 后台执行脚本，关闭窗口还是会停止                           |      |
| `nohub sh shellScript &`         | 后台执行脚本，关闭窗口也不会终止                           |      |
| `nohup Command [ Arg … ] [　& ]` | 用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行 |      |
| `>`                              | 代表重定向到标准输出，等价于下面这种                       |      |
| `> 1`                            | 代表重定向到标准输出                                       |      |
| `> 2`                            | 重定向到标准错误输出                                       |      |
| `commond 0< filename`            | 把标准输入重定向到filename文件中                           |      |
| `commond > filename 2 > &1`      | 把标准输出和标准错误一起重定向到filename文件中(覆盖)       |      |

### xargs

**`xargs`命令的作用，是将标准输入转为命令行参数。**

| 命令                                                         | 选项 | 说明                          |
| ------------------------------------------------------------ | ---- | ----------------------------- |
| `xargs`                                                      |      |                               |
| `echo "nameXnameXnameXname"|xargs -dX`                       | -d   | 接受的参数分隔符              |
| `echo "one.txt two.txt"|xargs -n1 find ./ -name`             | -n 1 | 一次接收多个参数              |
|                                                              | -L 1 | 指定将一行作为一次参数输入    |
| `cat a.txt | xargs -I file sh -c 'echo file; mkdir file'-L 1` | -I   | 指定每个参数的占位符          |
|                                                              | -p   | 打印出需要执行的命令 等待确认 |
|                                                              | -t   | 打印出需要执行的命令 无需确认 |

### awk

参考链接：https://www.ruanyifeng.com/blog/2018/11/awk.html

**格式：awk [选项] '[条件]{指令}' 文件**

```bash
# 格式
$ awk 动作 文件名

# 示例
$ awk '{print $0}' demo.txt

$ echo 'this is a test' | awk '{print $0}'
this is a test

$ echo 'this is a test' | awk '{print $3}'
a
```

**`$0`代表当前行**

`awk`会根据空格和制表符，将每一行分成若干字段，依次用**`$1`、`$2`、`$3`**代表第一个字段、第二个字段、第三个字段等等。

| 命令                                            | 选项   | 说明              |
| ----------------------------------------------- | ------ | ----------------- |
| **NR**                                          |        | number of records |
| **NF**                                          |        | number of fields  |
| **FS**                                          |        | field separator   |
| **RS**                                          |        | record separator  |
| `awk -F ':' '{ print $1 }' demo.txt`            | **-F** | 以`:`分割         |
| `$ awk -F ':' '{ print toupper($1) }' demo.txt` |        | toupper 函数      |

#### `awk`常用函数

-   `tolower()`：字符转为小写。
-   `length()`：返回字符串长度。
-   `substr()`：返回子字符串。
-   `sin()`：正弦。
-   `cos()`：余弦。
-   `sqrt()`：平方根。
-   `rand()`：随机数。

#### `awk`条件表达式

```bash
# print命令前面是一个正则表达式，只输出包含usr的行。
$ awk -F ':' '/usr/ {print $1}' demo.txt
```

**NF 当前行最后一个字段**

```bash
$ echo 'this is a test' | awk '{print $NF}'
test

# $(NF-1)代表倒数第二个字段。
$ awk -F ':' '{print $1, $(NF-1)}' demo.txt
```

### `sed`命令

**假设文件 fin.txt 中的内容如下**

```tex
hello Jobs
hello Pony
hello Jack,  hi Jack
```

-   替换

    ```bash
    # 替换第一个`Jack`为Mark
    sed '/s/Jack/Mark' fin.txt
    > hello Jobs
      hello Pony
      hello Mark,  hi Jack
    
    # 替换所有`Jack`为Mark
    sed '/s/Jack/Mark/g' fin.txt
    > hello Jobs
      hello Pony
      hello Mark,  hi Mark
      
    # 替换第2、3行`Jack`为Mark
    sed '2,3s/Jack/Mark/g' fin.txt
    > hello Jobs
      hello Pony
      hello Mark,  hi Mark  
      
    # 找出包含字符 Pony 的那些行，将这些行中的 hello 替换成 hey
    sed  '/Pony/s/hello/hey/g'  fin.txt
    >>
    hello Jobs
    hey   Pony
    hello Jack, hi Jack  
    ```

-   修改

    直接`-i`参数即可修改源文件

    ```bash
    # 修改第一个`Jack`为Mark
    sed -i '/s/Jack/Mark' fin.txt
    > hello Jobs
      hello Pony
      hello Mark,  hi Jack
      
    # 在第一行前面插入 welcome  
    sed -i '1i\welcome'  fin.txt
    >>
    welcome
    hello Jobs
    hello Pony
    hello Jack,  hi Jack  
    
    # 在第一行后面添加 welcome  
    sed -i  '1a\welcome'  fin.txt
    
    # 在匹配行的前面或者后面添加一行
    sed -i  '/Pony/a\welcome'  fin.txt
    >>
    hello Jobs
    hello Pony
    welcome
    hello Jack,  hi Jack
    
    # 在匹配行前面插入welcome
    sed -i  '/Pony/i\welcome'  fin.txt
    ```

-   **删除**

    ```bash
    # 删除 2~3 行
    sed  '2,3d'  fin.txt
    >>
    hello Jobs
    
    # 删除文件的第2行到末尾所有行
    sed '2,$d' fin.txt
    
    # 删除包含字符串 Pony 的行
    sed  '/Pony/d'  fin.txt
    >>
    hello Jobs
    hello Jack, hi Jack
    
    # 删除空白行
    sed  '/^$/d'  fin.txt
    
    # 删除包含任意个空格的空白行
    sed  '/^\s*$/d'  fin.txt
    
    # 删除不包含字符 Pony 的行
    sed  '/Pony/\!d'  fin.txt
    ```

    

## 函数

### 系统函数

```shell
# basename 函数 返回文件名
[root@lim shcode]# basename /usdf/asf/sdfs/file.txt
file.txt
[root@lim shcode]# basename /usdf/asf/sdfs/file.txt .txt
file

# dirname 函数 返回路径
[root@lim shcode]# dirname /usdf/asf/sdfs/file.txt
/usdf/asf/sdfs
```

#### 自定义函数

```shell
#!/bin/bash
function sum() {
        SUM=$[$n1+$n2]
        echo "结果是$SUM"
}
# 输入两个值
read -p "请输入一个数n1=" n1
read -p "请输入一个数n2=" n2

# 调用自定义函数
sum $n1 $n2
```

**数据库备份脚本**

```shell
#!/bin/bash

# 备份目录
BACKUP_PATH=/usr/local/mysql/backup
# 当前时间
TIMESTAMP=$(date "+%Y-%m-%d_%H%M%S")
echo "当前时间：$TIMESTAMP"
# mysql 地址
MYSQL_HOST=localhost
# mysql 用户
MYSQL_USER=root
# mysql 用户密码
MYSQL_PASS=123456
# mysql 备份数据库名
MYSQL_DATABASE=blog

# 判断备份目录是否存在 不存在则创建 && 如果前面的条件成立则执行后面的操作
[ ! -d $BACKUP_PATH ] && mkdir -p $BACKUP_PATH

# 数据库备份
mysqldump -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -q -R $MYSQL_DATABASE > $BACKUP_PATH/$TIMESTAMP.sql
# mysqldump -uroot -p123456 -q -R blog|gzip > to.sql.gz

# 文件打包
cd $BACKUP_PATH
tar -zcvf $TIMESTAMP.sql.tar.gz $TIMESTAMP.sql
rm -f $TIMESTAMP.sql

# 删除创建时间超过1分钟的文件的tar.gz文件
find $BACKUP_PATH -cmin +1 -name "*.tar.gz" -exec rm -rf {} \;
echo "备份结束"
```

## 日志相关

**日志文件目录 `/var/log`**

**日志配置文件 `/etc/rsyslog.conf`**

**日志轮替策略配置文件`/etc/logratate.conf`**

**日志轮替策略配置文件`/etc/logratate.d`**

### `curl`相关

```bash
curl -d '{"x" : 1}' -H "Content-Type: application/json" -X POST http://localhost:3000/api
curl -I -d '{"x" : 1}' -H "Content-Type: application/json" -X POST http://localhost:3000/api

-d 后面跟着要发送的数据
-X 后面是用到的 HTTP 方法
-H 是指定自定义的请求头。
-I 只查看http响应头
```

